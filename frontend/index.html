<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Value Finder vs Novig</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background-color: #111827;
            color: #e5e7eb;
            margin: 0;
            padding: 0;
        }

        header {
            padding: 1rem 1.5rem;
            background: #0f172a;
            border-bottom: 1px solid #1f2937;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.3rem;
        }

        header nav a {
            color: #9ca3af;
            text-decoration: none;
            font-size: 0.85rem;
            margin-left: 0.75rem;
        }

        header nav a:hover {
            color: #e5e7eb;
        }

        header nav a.active {
            color: #e5e7eb;
            font-weight: 500;
        }

        main {
            padding: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: #020617;
            border-radius: 0.75rem;
            border: 1px solid #1f2937;
            padding: 1rem 1.25rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }

        .card h2 {
            margin-top: 0;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        label {
            display: block;
            font-size: 0.85rem;
            margin-top: 0.6rem;
            margin-bottom: 0.15rem;
            color: #9ca3af;
        }

        select,
        input[type="number"] {
            width: 100%;
            padding: 0.45rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid #374151;
            background: #020617;
            color: #e5e7eb;
            box-sizing: border-box;
            font-size: 0.9rem;
        }

        input[type="checkbox"] {
            margin-right: 0.35rem;
        }

        .btn {
            border: none;
            border-radius: 0.5rem;
            padding: 0.5rem 0.9rem;
            font-size: 0.9rem;
            cursor: pointer;
            margin-right: 0.5rem;
            margin-top: 0.75rem;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-secondary {
            background: #374151;
            color: #e5e7eb;
        }

        .btn-link {
            background: transparent;
            border: 1px solid #374151;
            color: #e5e7eb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: default;
        }

        .status-bar {
            font-size: 0.8rem;
            color: #9ca3af;
            margin-top: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        th,
        td {
            border-bottom: 1px solid #1f2937;
            padding: 0.4rem 0.5rem;
            text-align: left;
            vertical-align: top;
        }

        th {
            background: #020617;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .scroll-container {
            max-height: 520px;
            overflow-y: auto;
        }

        .small-text {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .badge {
            display: inline-block;
            border-radius: 999px;
            padding: 0.1rem 0.45rem;
            font-size: 0.7rem;
        }

        .badge-positive {
            background: #166534;
            color: #bbf7d0;
        }

        .badge-negative {
            background: #7f1d1d;
            color: #fecaca;
        }

        .sgp-card {
            margin-top: 0.75rem;
            padding: 0.9rem;
            border-radius: 0.5rem;
            background: #111827;
            border: 1px solid #1f2937;
        }

        .team-logo {
            width: 24px;
            height: 24px;
            vertical-align: middle;
            margin-right: 0.4rem;
            display: inline-block;
            object-fit: contain;
        }

        .team-name-with-logo {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .toggle-on {
            background: #16a34a;
            color: #e5e7eb;
            border-color: #15803d;
        }

        @media (max-width: 900px) {
            main {
                grid-template-columns: minmax(0, 1fr);
            }
        }
    </style>
</head>

<body>
    <header>
        <div>
            <h1>Value Finder</h1>
            <div class="small-text">
                Compare a book's lines to another book and see the hedgeable opposite side.
            </div>
        </div>
        <nav>
            <a href="/" class="active">Value Finder</a>
            <a href="/watcher.html">Watcher</a>
        </nav>
    </header>

    <main>
        <!-- Best Value Finder Section -->
        <section class="card">
            <h2>Value Finder (Multi-Sport)</h2>
            <div class="small-text" style="margin-bottom: 0.75rem;">
                Find the best +EV bets across multiple sports and markets
            </div>

            <label>Select Sports (multiple)</label>
            <div style="margin-bottom: 0.5rem;">
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="sport-checkbox" value="basketball_nba" checked />
                    <span style="margin-left: 0.5rem;">NBA</span>
                </label>
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="sport-checkbox" value="americanfootball_nfl" />
                    <span style="margin-left: 0.5rem;">NFL</span>
                </label>
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="sport-checkbox" value="basketball_ncaab" />
                    <span style="margin-left: 0.5rem;">NCAAB</span>
                </label>
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="sport-checkbox" value="americanfootball_ncaaf" />
                    <span style="margin-left: 0.5rem;">NCAAF</span>
                </label>
            </div>

            <label>Select Markets (multiple)</label>
            <div style="margin-bottom: 0.5rem;">
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="market-checkbox" value="h2h" checked />
                    <span style="margin-left: 0.5rem;">Moneyline (h2h)</span>
                </label>
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="market-checkbox" value="spreads" checked />
                    <span style="margin-left: 0.5rem;">Spreads</span>
                </label>
                <label style="display: flex; align-items: center; margin-top: 0.3rem;">
                    <input type="checkbox" class="market-checkbox" value="totals" checked />
                    <span style="margin-left: 0.5rem;">Totals</span>
                </label>
            </div>

            <label for="best-target-book-select">Target book</label>
            <select id="best-target-book-select">
                <option value="draftkings">DraftKings</option>
                <option value="fanduel">FanDuel</option>
                <option value="fliff">Fliff</option>
                <option value="novig">Novig</option>
            </select>

            <label for="best-compare-book-select">Compare against</label>
            <select id="best-compare-book-select">
                <option value="novig" selected>Novig</option>
                <option value="draftkings">DraftKings</option>
                <option value="fanduel">FanDuel</option>
                <option value="fliff">Fliff</option>
            </select>

            <label for="best-max-results-input">Max results</label>
            <input id="best-max-results-input" type="number" min="10" max="200" step="10" value="50" />

            <label style="display: flex; align-items: center; margin-top: 0.75rem; padding: 0.5rem; background: #1f2937; border-radius: 4px;">
                <input type="checkbox" id="dummy-data-checkbox" style="margin-right: 0.5rem;" />
                <span>Use Dummy Data (for development when API credits are exhausted)</span>
            </label>

            <div style="margin-top: 0.75rem;">
                <button class="btn btn-primary" id="find-best-btn">Find Best Value Plays</button>
                <button class="btn btn-secondary" id="profit-boost-btn">Find Profit Boost Plays (+200+)</button>
                <button class="btn btn-secondary" id="clear-best-btn">Clear</button>
            </div>

            <div class="status-bar" id="best-status-bar">Ready.</div>
        </section>

        <!-- Best Value Results Section -->
        <section class="card" id="best-results-section" style="display: none;">
            <h2>Best Value Plays (All Sports/Markets)</h2>
            <div class="small-text" id="best-summary-bar"></div>
            <div class="scroll-container">
                <table>
                    <thead>
                        <tr>
                            <th>Sport</th>
                            <th>Market</th>
                            <th>Outcome (Book)</th>
                            <th>Matchup</th>
                            <th>Start Time</th>
                            <th>Compare Price</th>
                            <th>Opposite Side</th>
                            <th>Hedge Bet (Book)</th>
                            <th>Value Bet (Book)</th>
                            <th>Hedge EV%</th>
                            <th>EV% (approx)</th>
                        </tr>
                    </thead>
                    <tbody id="best-results-body">
                    </tbody>
                </table>
            </div>
        </section>
    </main>

    <script>
        let valuePollTimer = null;
        let lastValueData = null;
        let filterHedgeOnly = false;

        function formatStartTime(isoString) {
            if (!isoString) return "";
            try {
                const date = new Date(isoString);
                const options = {
                    timeZone: "America/New_York",
                    month: "short",
                    day: "numeric",
                    hour: "numeric",
                    minute: "2-digit",
                    hour12: true,
                };
                return date.toLocaleString("en-US", options) + " ET";
            } catch (e) {
                return isoString;
            }
        }

        function getTeamLogoUrl(teamName, sportKey = null) {
            if (!teamName) return null;
            
            // Team name to ESPN team code mapping
            const teamMapping = {
                // NBA
                "atlanta hawks": "atl",
                "boston celtics": "bos",
                "brooklyn nets": "bkn",
                "charlotte hornets": "cha",
                "chicago bulls": "chi",
                "cleveland cavaliers": "cle",
                "dallas mavericks": "dal",
                "denver nuggets": "den",
                "detroit pistons": "det",
                "golden state warriors": "gs",
                "houston rockets": "hou",
                "indiana pacers": "ind",
                "los angeles clippers": "lac",
                "los angeles lakers": "lal",
                "memphis grizzlies": "mem",
                "miami heat": "mia",
                "milwaukee bucks": "mil",
                "minnesota timberwolves": "min",
                "new orleans pelicans": "no",
                "new york knicks": "ny",
                "oklahoma city thunder": "okc",
                "orlando magic": "orl",
                "philadelphia 76ers": "phi",
                "phoenix suns": "phx",
                "portland trail blazers": "por",
                "sacramento kings": "sac",
                "san antonio spurs": "sa",
                "toronto raptors": "tor",
                "utah jazz": "utah",
                "washington wizards": "wsh",
                // NFL
                "arizona cardinals": "ari",
                "atlanta falcons": "atl",
                "baltimore ravens": "bal",
                "buffalo bills": "buf",
                "carolina panthers": "car",
                "chicago bears": "chi",
                "cincinnati bengals": "cin",
                "cleveland browns": "cle",
                "dallas cowboys": "dal",
                "denver broncos": "den",
                "detroit lions": "det",
                "green bay packers": "gb",
                "houston texans": "hou",
                "indianapolis colts": "ind",
                "jacksonville jaguars": "jax",
                "kansas city chiefs": "kc",
                "las vegas raiders": "lv",
                "los angeles chargers": "lac",
                "los angeles rams": "lar",
                "miami dolphins": "mia",
                "minnesota vikings": "min",
                "new england patriots": "ne",
                "new orleans saints": "no",
                "new york giants": "nyg",
                "new york jets": "nyj",
                "philadelphia eagles": "phi",
                "pittsburgh steelers": "pit",
                "san francisco 49ers": "sf",
                "seattle seahawks": "sea",
                "tampa bay buccaneers": "tb",
                "tennessee titans": "ten",
                "washington commanders": "wsh"
            };
            
            const normalized = teamName.toLowerCase().trim();
            let teamCode = teamMapping[normalized];
            
            // If no mapping found, try to extract from common patterns
            if (!teamCode) {
                // Try to match partial names
                for (const [key, code] of Object.entries(teamMapping)) {
                    if (normalized.includes(key) || key.includes(normalized)) {
                        teamCode = code;
                        break;
                    }
                }
            }
            
            // Determine sport for ESPN URL
            let sportPath = "nba";
            if (sportKey) {
                if (sportKey.includes("football") || sportKey.includes("nfl") || sportKey.includes("ncaaf")) {
                    sportPath = "nfl";
                } else if (sportKey.includes("basketball") || sportKey.includes("nba") || sportKey.includes("ncaab")) {
                    sportPath = "nba";
                }
            }
            
            if (teamCode) {
                return `https://a.espncdn.com/i/teamlogos/${sportPath}/500/${teamCode}.png`;
            }
            
            // Fallback: try normalized name
            const fallback = normalized.replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            return `https://a.espncdn.com/i/teamlogos/${sportPath}/500/${fallback}.png`;
        }

        function createTeamNameWithLogo(teamName, sportKey = null) {
            if (!teamName) return document.createTextNode("");
            
            const container = document.createElement("span");
            container.className = "team-name-with-logo";
            
            const logo = document.createElement("img");
            logo.className = "team-logo";
            logo.src = getTeamLogoUrl(teamName, sportKey);
            logo.alt = teamName;
            logo.onerror = function() {
                // Hide logo if it fails to load
                this.style.display = "none";
            };
            
            const nameSpan = document.createElement("span");
            nameSpan.textContent = teamName;
            
            container.appendChild(logo);
            container.appendChild(nameSpan);
            
            return container;
        }

        function parseTeamFromOutcome(outcomeName) {
            // Extract team name from outcome (might include point spread info)
            // Examples: "New York Knicks", "New York Knicks @ -3.5"
            if (!outcomeName) return null;
            
            // Remove point spread info (everything after @)
            const parts = outcomeName.split(" @ ");
            return parts[0].trim();
        }

        function parseTeamsFromMatchup(matchup) {
            // Parse "Away Team @ Home Team" format
            if (!matchup) return { away: null, home: null };
            
            const parts = matchup.split(" @ ");
            if (parts.length === 2) {
                return { away: parts[0].trim(), home: parts[1].trim() };
            }
            return { away: matchup, home: null };
        }


        function setStatus(msg) {
            document.getElementById("status-bar").textContent = msg;
        }

        function setSummary(msg) {
            document.getElementById("summary-bar").textContent = msg;
        }

        function clearResults() {
            const body = document.getElementById("results-body");
            body.innerHTML = '<tr><td colspan="9" class="small-text">No results yet.</td></tr>';
            document.getElementById("sgp-container").innerHTML = "";
            setSummary("");
            lastValueData = null;
        }

        function renderValuePlays(data, hedgeOnly = false) {
            const body = document.getElementById("results-body");
            body.innerHTML = "";

            if (!data || !data.plays || data.plays.length === 0) {
                const compareBookLabel = document.querySelector("#compare-book-select option:checked")?.textContent || "comparison book";
                body.innerHTML = `<tr><td colspan="9" class="small-text">No value plays found (maybe market is empty or ${compareBookLabel} not available).</td></tr>`;
                return;
            }

            let plays = data.plays;
            if (hedgeOnly) {
                plays = plays.filter(p =>
                    p.novig_reverse_name !== null &&
                    p.novig_reverse_name !== undefined &&
                    p.novig_reverse_price !== null &&
                    p.novig_reverse_price !== undefined
                );
            }

            if (plays.length === 0) {
                body.innerHTML = '<tr><td colspan="9" class="small-text">No plays match the current hedge filter.</td></tr>';
                return;
            }

            const currentSport = document.getElementById("sport-select").value;
            plays.forEach(play => {
                const tr = document.createElement("tr");

                const outcomeCell = document.createElement("td");
                const teamName = parseTeamFromOutcome(play.outcome_name);
                const teamWithLogo = createTeamNameWithLogo(teamName, play.sport_key || currentSport);
                outcomeCell.appendChild(teamWithLogo);
                if (play.point !== null && play.point !== undefined) {
                    const pointSpan = document.createElement("span");
                    pointSpan.textContent = " @ " + play.point;
                    outcomeCell.appendChild(pointSpan);
                }
                tr.appendChild(outcomeCell);

                const matchupCell = document.createElement("td");
                const teams = parseTeamsFromMatchup(play.matchup);
                if (teams.away && teams.home) {
                    matchupCell.appendChild(createTeamNameWithLogo(teams.away, play.sport_key || currentSport));
                    const vsSpan = document.createElement("span");
                    vsSpan.textContent = " @ ";
                    vsSpan.style.margin = "0 0.3rem";
                    matchupCell.appendChild(vsSpan);
                    matchupCell.appendChild(createTeamNameWithLogo(teams.home, play.sport_key || currentSport));
                } else {
                    matchupCell.textContent = play.matchup || "";
                }
                tr.appendChild(matchupCell);

                const startCell = document.createElement("td");
                startCell.textContent = play.start_time || "";
                tr.appendChild(startCell);

                const compareCell = document.createElement("td");
                compareCell.textContent = play.novig_price;
                tr.appendChild(compareCell);

                const oppCell = document.createElement("td");
                if (play.novig_reverse_name) {
                    const oppTeamName = parseTeamFromOutcome(play.novig_reverse_name);
                    oppCell.appendChild(createTeamNameWithLogo(oppTeamName, play.sport_key || currentSport));
                } else {
                    oppCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(oppCell);

                const hedgeCell = document.createElement("td");
                if (play.novig_reverse_price !== null && play.novig_reverse_price !== undefined) {
                    const compareBookLabel = document.querySelector("#compare-book-select option:checked")?.textContent || data.compare_book || "Compare";
                    hedgeCell.innerHTML = `<strong>${play.novig_reverse_price}</strong><br><span class="small-text">@ ${compareBookLabel}</span>`;
                } else {
                    hedgeCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(hedgeCell);

                const bookCell = document.createElement("td");
                const targetBookLabel = document.querySelector("#book-select option:checked")?.textContent || data.target_book || "Target";
                bookCell.innerHTML = `<strong>${play.book_price}</strong><br><span class="small-text">@ ${targetBookLabel}</span>`;
                tr.appendChild(bookCell);

                const hedgeEvCell = document.createElement("td");
                if (play.arb_margin_percent !== null && play.arb_margin_percent !== undefined) {
                    const hedgeRounded = Math.round(play.arb_margin_percent * 100) / 100;
                    const hedgeClass = hedgeRounded >= 0 ? "badge badge-positive" : "badge badge-negative";
                    hedgeEvCell.innerHTML = `<span class="${hedgeClass}">${hedgeRounded}%</span>`;
                } else {
                    hedgeEvCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(hedgeEvCell);

                const evCell = document.createElement("td");
                const evRounded = Math.round(play.ev_percent * 100) / 100;
                let badgeClass = evRounded >= 0 ? "badge badge-positive" : "badge badge-negative";
                evCell.innerHTML = `<span class="${badgeClass}">${evRounded}%</span>`;
                tr.appendChild(evCell);


                body.appendChild(tr);
            });
        }

        function renderValueFromState() {
            if (!lastValueData) return;
            renderValuePlays(lastValueData, filterHedgeOnly);
        }

        function renderSGP(sgp, bookLabel) {
            const container = document.getElementById("sgp-container");
            container.innerHTML = "";
            if (!sgp) return;

            const card = document.createElement("div");
            card.className = "sgp-card";

            const header = document.createElement("div");
            header.innerHTML = `<strong>3-Leg High-EV Parlay Suggestion @ ${bookLabel}</strong>`;
            card.appendChild(header);

            const legsList = document.createElement("ul");
            legsList.className = "small-text";
            sgp.legs.forEach((leg, idx) => {
                const li = document.createElement("li");
                let text = `[Leg ${idx + 1}] ${leg.matchup}: ${leg.outcome_name}`;
                if (leg.point !== null && leg.point !== undefined) {
                    text += ` @ ${leg.point}`;
                }
                const compareBookLabel = document.querySelector("#compare-book-select option:checked")?.textContent || "comparison book";
                text += ` | Book: ${leg.book_price}, ${compareBookLabel}: ${leg.novig_price}, EV: ${leg.ev_percent}%`;
                li.textContent = text;
                legsList.appendChild(li);
            });
            card.appendChild(legsList);

            const footer = document.createElement("div");
            footer.className = "small-text";
            const compareBookLabel = document.querySelector("#compare-book-select option:checked")?.textContent || "comparison book";
            footer.innerHTML = `
        Approx parlay decimal odds: <strong>${sgp.approx_parlay_decimal_odds}</strong><br />
        Approx parlay EV: <strong>${sgp.approx_parlay_ev_percent}%</strong> (vs ${compareBookLabel} as sharp)
      `;
            card.appendChild(footer);

            container.appendChild(card);
        }

        async function fetchValuePlays(singleRun = false) {
            const sport = document.getElementById("sport-select").value;
            const market = document.getElementById("market-select").value;
            const book = document.getElementById("book-select").value;
            const compareBook = document.getElementById("compare-book-select").value;
            const maxResults = Number(document.getElementById("max-results-input").value) || 25;
            const includeSGP = document.getElementById("sgp-checkbox").checked;

            if (book === compareBook) {
                setStatus("Error: Target book and comparison book cannot be the same.");
                return;
            }

            if (singleRun) {
                // Don't wipe lastValueData instantly; let new data overwrite.
                setSummary("");
            }
            setStatus("Fetching value plays...");
            try {
                const res = await fetch("/api/value-plays", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        sport_key: sport,
                        market,
                        target_book: book,
                        compare_book: compareBook,
                        include_sgp: includeSGP,
                        max_results: maxResults
                    }),
                });
                if (!res.ok) {
                    const text = await res.text();
                    throw new Error(text || ("HTTP " + res.status));
                }
                const data = await res.json();
                lastValueData = data;
                renderValueFromState();

                const playsCount = (data.plays || []).length;
                const compareBookLabel = document.querySelector("#compare-book-select option:checked").textContent;
                setSummary(`Showing top ${playsCount} raw value plays for ${book} in market "${market}" vs ${compareBookLabel}. Filter: ${filterHedgeOnly ? "Hedgeable only" : "All"}.`);
                const bookLabel = document.querySelector("#book-select option:checked").textContent;
                renderSGP(data.sgp_suggestion, bookLabel);
                setStatus("Done.");
            } catch (e) {
                console.error(e);
                setStatus("Error: " + e.message);
            }
        }

        function startValueLoop() {
            const intervalInput = document.getElementById("interval-input");
            const intervalVal = Number(intervalInput.value) || 60;
            const intervalMs = Math.max(intervalVal, 15) * 1000; // min 15 seconds

            if (valuePollTimer) {
                clearInterval(valuePollTimer);
                valuePollTimer = null;
            }

            setStatus("Watching value plays...");
            document.getElementById("start-loop-btn").disabled = true;
            document.getElementById("find-btn").disabled = true;
            document.getElementById("stop-loop-btn").disabled = false;

            // initial fetch
            fetchValuePlays(true);
            valuePollTimer = setInterval(() => fetchValuePlays(false), intervalMs);
        }

        function stopValueLoop() {
            if (valuePollTimer) {
                clearInterval(valuePollTimer);
                valuePollTimer = null;
            }
            setStatus("Stopped.");
            document.getElementById("start-loop-btn").disabled = false;
            document.getElementById("find-btn").disabled = false;
            document.getElementById("stop-loop-btn").disabled = true;
        }

        function toggleHedgeFilter() {
            filterHedgeOnly = !filterHedgeOnly;
            const btn = document.getElementById("filter-opp-btn");
            if (filterHedgeOnly) {
                btn.classList.add("toggle-on");
                btn.textContent = "Filter: Hedgeable Only (ON)";
            } else {
                btn.classList.remove("toggle-on");
                btn.textContent = "Filter: Hedgeable Only (OFF)";
            }
            renderValueFromState();
        }

        // Best Value Finder Functions
        function setBestStatus(msg) {
            document.getElementById("best-status-bar").textContent = msg;
        }

        function setBestSummary(msg) {
            document.getElementById("best-summary-bar").textContent = msg;
        }

        function clearBestResults() {
            const body = document.getElementById("best-results-body");
            body.innerHTML = "";
            document.getElementById("best-results-section").style.display = "none";
            setBestSummary("");
        }

        function renderBestValuePlays(data, profitBoostOnly = false) {
            const body = document.getElementById("best-results-body");
            body.innerHTML = "";
            const section = document.getElementById("best-results-section");
            section.style.display = "block";

            if (!data || !data.plays || data.plays.length === 0) {
                body.innerHTML = '<tr><td colspan="11" class="small-text">No value plays found.</td></tr>';
                return;
            }

            let plays = data.plays;
            
            // Filter for profit boost plays (+200 to +300, and above +300)
            if (profitBoostOnly) {
                plays = plays.filter(p => p.book_price >= 200);
                if (plays.length === 0) {
                    body.innerHTML = '<tr><td colspan="11" class="small-text">No profit boost plays found (+200 odds and above).</td></tr>';
                    return;
                }
            }

            const sportLabels = {
                "basketball_nba": "NBA",
                "americanfootball_nfl": "NFL",
                "basketball_ncaab": "NCAAB",
                "americanfootball_ncaaf": "NCAAF"
            };

            const marketLabels = {
                "h2h": "Moneyline",
                "spreads": "Spreads",
                "totals": "Totals"
            };

            plays.forEach(play => {
                const tr = document.createElement("tr");

                const sportCell = document.createElement("td");
                sportCell.textContent = sportLabels[play.sport_key] || play.sport_key;
                tr.appendChild(sportCell);

                const marketCell = document.createElement("td");
                marketCell.textContent = marketLabels[play.market] || play.market;
                tr.appendChild(marketCell);

                const outcomeCell = document.createElement("td");
                const teamName = parseTeamFromOutcome(play.outcome_name);
                const teamWithLogo = createTeamNameWithLogo(teamName, play.sport_key || null);
                outcomeCell.appendChild(teamWithLogo);
                if (play.point !== null && play.point !== undefined) {
                    const pointSpan = document.createElement("span");
                    pointSpan.textContent = " @ " + play.point;
                    outcomeCell.appendChild(pointSpan);
                }
                tr.appendChild(outcomeCell);

                const matchupCell = document.createElement("td");
                const teams = parseTeamsFromMatchup(play.matchup);
                if (teams.away && teams.home) {
                    matchupCell.appendChild(createTeamNameWithLogo(teams.away, play.sport_key || null));
                    const vsSpan = document.createElement("span");
                    vsSpan.textContent = " @ ";
                    vsSpan.style.margin = "0 0.3rem";
                    matchupCell.appendChild(vsSpan);
                    matchupCell.appendChild(createTeamNameWithLogo(teams.home, play.sport_key || null));
                } else {
                    matchupCell.textContent = play.matchup || "";
                }
                tr.appendChild(matchupCell);

                const startCell = document.createElement("td");
                startCell.textContent = play.start_time || "";
                tr.appendChild(startCell);

                const compareCell = document.createElement("td");
                compareCell.textContent = play.novig_price;
                tr.appendChild(compareCell);

                const oppCell = document.createElement("td");
                if (play.novig_reverse_name) {
                    const oppTeamName = parseTeamFromOutcome(play.novig_reverse_name);
                    oppCell.appendChild(createTeamNameWithLogo(oppTeamName, play.sport_key || null));
                } else {
                    oppCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(oppCell);

                const hedgeCell = document.createElement("td");
                if (play.novig_reverse_price !== null && play.novig_reverse_price !== undefined) {
                    const compareBookLabel = document.querySelector("#best-compare-book-select option:checked")?.textContent || data.compare_book || "Compare";
                    hedgeCell.innerHTML = `<strong>${play.novig_reverse_price}</strong><br><span class="small-text">@ ${compareBookLabel}</span>`;
                } else {
                    hedgeCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(hedgeCell);

                const bookCell = document.createElement("td");
                const targetBookLabel = document.querySelector("#best-target-book-select option:checked")?.textContent || data.target_book || "Target";
                bookCell.innerHTML = `<strong>${play.book_price}</strong><br><span class="small-text">@ ${targetBookLabel}</span>`;
                tr.appendChild(bookCell);

                const hedgeEvCell = document.createElement("td");
                if (play.arb_margin_percent !== null && play.arb_margin_percent !== undefined) {
                    const hedgeRounded = Math.round(play.arb_margin_percent * 100) / 100;
                    const hedgeClass = hedgeRounded >= 0 ? "badge badge-positive" : "badge badge-negative";
                    hedgeEvCell.innerHTML = `<span class="${hedgeClass}">${hedgeRounded}%</span>`;
                } else {
                    hedgeEvCell.innerHTML = '<span class="small-text">-</span>';
                }
                tr.appendChild(hedgeEvCell);

                const evCell = document.createElement("td");
                const evRounded = Math.round(play.ev_percent * 100) / 100;
                let badgeClass = evRounded >= 0 ? "badge badge-positive" : "badge badge-negative";
                evCell.innerHTML = `<span class="${badgeClass}">${evRounded}%</span>`;
                tr.appendChild(evCell);

                body.appendChild(tr);
            });
        }

        let lastBestValueData = null;

        async function fetchBestValuePlays(profitBoostOnly = false) {
            const sportCheckboxes = document.querySelectorAll(".sport-checkbox:checked");
            const marketCheckboxes = document.querySelectorAll(".market-checkbox:checked");
            const targetBook = document.getElementById("best-target-book-select").value;
            const compareBook = document.getElementById("best-compare-book-select").value;
            const maxResults = Number(document.getElementById("best-max-results-input").value) || 50;
            const useDummyData = document.getElementById("dummy-data-checkbox").checked;

            if (sportCheckboxes.length === 0) {
                setBestStatus("Error: Please select at least one sport.");
                return;
            }

            if (marketCheckboxes.length === 0) {
                setBestStatus("Error: Please select at least one market.");
                return;
            }

            if (targetBook === compareBook) {
                setBestStatus("Error: Target book and comparison book cannot be the same.");
                return;
            }

            const sportKeys = Array.from(sportCheckboxes).map(cb => cb.value);
            const markets = Array.from(marketCheckboxes).map(cb => cb.value);

            setBestStatus(profitBoostOnly ? "Searching for profit boost plays (+200 odds and above)..." : "Searching across sports and markets...");
            if (useDummyData) {
                setBestStatus((profitBoostOnly ? "Searching for profit boost plays (+200 odds and above)..." : "Searching across sports and markets...") + " [DUMMY DATA MODE]");
            }
            clearBestResults();

            try {
                const res = await fetch("/api/best-value-plays", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        sport_keys: sportKeys,
                        markets: markets,
                        target_book: targetBook,
                        compare_book: compareBook,
                        max_results: maxResults * 2,  // Get more results to filter from
                        use_dummy_data: useDummyData
                    }),
                });
                if (!res.ok) {
                    const text = await res.text();
                    throw new Error(text || ("HTTP " + res.status));
                }
                const data = await res.json();
                lastBestValueData = data;
                renderBestValuePlays(data, profitBoostOnly);

                let playsCount = (data.plays || []).length;
                if (profitBoostOnly) {
                    playsCount = data.plays.filter(p => p.book_price >= 200).length;
                }
                const compareBookLabel = document.querySelector("#best-compare-book-select option:checked").textContent;
                if (profitBoostOnly) {
                    setBestSummary(`Found ${playsCount} profit boost plays (+200 to +300+ odds) across ${sportKeys.length} sport(s) and ${markets.length} market(s). Sorted by Hedge EV% (vs ${compareBookLabel}).`);
                } else {
                    setBestSummary(`Found ${playsCount} best value plays across ${sportKeys.length} sport(s) and ${markets.length} market(s). Sorted by Hedge EV% (vs ${compareBookLabel}).`);
                }
                setBestStatus("Done.");
            } catch (e) {
                console.error(e);
                setBestStatus("Error: " + e.message);
            }
        }

        window.addEventListener("DOMContentLoaded", () => {
            // Load dummy data setting from localStorage
            const dummyDataCheckbox = document.getElementById("dummy-data-checkbox");
            const savedDummyData = localStorage.getItem("useDummyData");
            if (savedDummyData === "true") {
                dummyDataCheckbox.checked = true;
            }
            
            // Save dummy data setting to localStorage when changed
            dummyDataCheckbox.addEventListener("change", (e) => {
                localStorage.setItem("useDummyData", e.target.checked ? "true" : "false");
            });
            
            // Best Value Finder buttons
            document.getElementById("find-best-btn").onclick = () => fetchBestValuePlays(false);
            document.getElementById("profit-boost-btn").onclick = () => fetchBestValuePlays(true);
            document.getElementById("clear-best-btn").onclick = clearBestResults;

            // Best value finder book validation
            const bestTargetBook = document.getElementById("best-target-book-select");
            const bestCompareBook = document.getElementById("best-compare-book-select");
            
            function validateBestBookSelection() {
                if (bestTargetBook.value === bestCompareBook.value) {
                    setBestStatus("Error: Target book and comparison book cannot be the same.");
                    return false;
                }
                return true;
            }
            
            bestTargetBook.addEventListener("change", validateBestBookSelection);
            bestCompareBook.addEventListener("change", validateBestBookSelection);
        });
    </script>
</body>

</html>